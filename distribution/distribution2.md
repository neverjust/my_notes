# 分布式

## 一致性

一致性的原因就是数据副本（主从库同步，异步处理返回）。

**强一致性**：同步处理，流程是线性的，但如果从库宕机或网络阻塞，主库就无法完成写入操作。在实践中，我们通常**使一个从库是同步的，而其他的则是异步的**。如果这个同步的从库出现问题，则使另一个异步从库同步。这种配置称为**半同步。**

**最终一致性**：主库写成功后立刻返回，异步同步给从库。当用户从**异步从库**读取时，**如果此异步从库落后，他可能会看到过时的信息。**这种不一致只是一个**暂时的状态**——如果等待一段时间，从库最终会赶上并与主库保持一致。这称为**最终一致性。**

**读写一致性**：

> 手机刷虎扑的时候经常遇到，回复某人的帖子然后想马上查看，但我刚提交的回复可能尚未到达从库，看起来好像是刚提交的数据丢失了。**对于某些特定的内容，都从主库读。**
>
> 最简单的方案，**对于某些特定的内容，都从主库读。**举个例子，知乎个人主页信息只能由用户本人编辑，而不能由其他人编辑。因此，永远从主库读取用户自己的个人主页，从从库读取其他用户的个人主页。
>
> 如果应用中的大部分内容都可能被用户编辑，那这种方法就没用了。在这种情况下可以使用其他标准来决定是否从主库读取，例如可以**记录每个用户最后一次写入主库的时间**，一分钟内都从主库读，同时**监控从库的最后同步时间**，任何超过一分钟没有更新的从库不响应查询。
>
> 还有一种更好的方法是，客户端可以**在本地记住最近一次写入的时间戳**，发起请求时带着此时间戳。从库提供任何查询服务前，需确保**该时间戳前的变更都已经同步到了本从库中**。如果当前从库不够新，则可以从另一个从库读，或者等待从库追赶上来。

**单调读：**

> 用户从某从库查询到了一条记录，再次刷新后发现此记录不见了，就像遇到**时光倒流**。如果用户从不同从库进行多次读取，就可能发生这种情况。
>
> **单调读**可以保证这种异常不会发生。单调读意味着如果一个用户进行多次读取时，绝对不会遇到时光倒流，即**如果先前读取到较新的数据，后续读取不会得到更旧的数据。**单调读**比强一致性更弱，比最终一致性更强。**
>
> 实现单调读取的一种方式是**确保每个用户总是从同一个节点进行读取**（不同的用户可以从不同的节点读取），比如可以基于用户ID的哈希值来选择节点，而不是随机选择节点。

**因果一致性**：

