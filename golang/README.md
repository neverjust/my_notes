## GPM模型为什么要有P

首先说一下GPM都是什么

> **G**就是我们常用的groutine，操作系统不可感知完全由Golang自己进行维护的用户级的线程，又叫协程。
>
> **P**是处理器，维护一个G的本地队列，M只能通过绑定P来执行G。
>
> **M**是thread系统线程，执行G任务。

**如果只有G和M的话，会有几个问题：**

1. 全局的G队列需要加锁，创建、销毁、调度 G 都需要每个 M 获取锁，这就形成了激烈的锁竞争。
2. M 转移 G 会造成延迟和额外的系统负载。比如当 G 中包含创建新协程的时候，M 创建了 G’，为了继续执行 G，需要把 G’交给 M’执行，也造成了很差的局部性，因为 G’和 G 是相关的，最好放在 M 上执行，而不是其他 M’。
3. 系统调用 (CPU 在 M 之间的切换) 导致频繁的线程阻塞和取消阻塞操作增加了系统开销。

**为什么设计P这个组件：**

1. 避免频繁访问全局G队列，减少锁竞争。（work stealing 机制）

   P包含本地G队列，优先从本地队列中获取G执行，同时实现了work stealing机制，当本地G队列为空时，优先从其他的P偷取G。

2. 解决M被系统调用时，导致的阻塞。（ hand off 机制）

    当本线程M因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。

**为什么不直接在M上实现本地队列、Work Stealing 算法，而是要引入P呢？**

- 一般来讲，M 的数量都会多于 P。像在 Go 中，M 的数量默认是 10000，P 的默认数量的 CPU 核数。另外由于 M 的属性，也就是如果存在系统阻塞调用，阻塞了 M，又不够用的情况下，M 会不断增加。
- M 不断增加的话，如果本地队列挂载在 M 上，那就意味着本地队列也会随之增加。这显然是不合理的，因为本地队列的管理会变得复杂，且 Work Stealing 性能会大幅度下降。
- M 被系统调用阻塞后，我们是期望把他既有未执行的任务分配给其他继续运行的，而不是一阻塞就导致全部停止。

## 协程抢占

调度器历史：

- Go1.1：基于任务窃取的调度器。
- Go1.2 - Go1.13：基于协作的抢占式调度器。
- Go1.14：基于信号的抢占式调度器。



